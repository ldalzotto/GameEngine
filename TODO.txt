-- TODO --

-- 1st Milestone -- 

# Creating a first milestone application that showcase all implemented features :
	## Transform parenting, rotation, ...
	## AABB physics detection

-- Documentation --

# Creating a documentation format in html/css that will be used to functionaly describe the architecture of the GameEngine.
This documentation will discuss about : 
	## The main execution flow of the game engine.
	## Generalization of procedures. (Like MaterialInstance creation for render)
	## How data is organized. (Like Texture, Material ...). Maybe having a data hierarchy graph ?
	## Why some system implementation details are made.
	## A very small description of what systems/algorithm can do with their limitation and future improvements.
This documentation won't discuss of :
	## Implementation details of algorithm.
	## What every method is doing (we are never talking about code).

-- Data Structures --

# Separating Structure operation from object.
# Instead of locking operations to only one king of structure, creating generic object (like Iterator, Writer, ...) that can be created from structures. Then
  algorithm are executed on them instead of data structures.

-- Physics --

# Adding Layers to BoxCollider.
# Allow Raycasting by filtering by Layers.

-- Editor - Click world Listener --

# Implementing a system in the Editor module that listens to mouse click and populate flags according to listeners.
	## MouseClickListers is just a tag component.

-- Editor - Transform Gizmo --

# Creating a Transform Gizmo.
	# With a special Material that is not dependant of the camera projection ? (to always have the same size on screen).
	# Allowing gizmo to move depending on which arrow is clicked.

-- Materials --

# Adding configuration properties for blending (editor 3D gizmo may be transparent ?)


~~ LONG TERM OBJECTIVES ~~

-- Resources --

# Implementing my own 3D model exporter in blender and imported in the GameEngine to have total control about Mesh loading and directly mapping to known data.

-- Editor GUI --

# Removing dependencies to the IMGui library. This will involve :
	## Creating my own GUI Layout system. (maybe we can have somthing similar to unity ?)
	## 

-- Graphics improvements --

# Instead of having multiple small vulkan buffer, we can have a single one that manually fragment and allocate memory on need.
# Simplifying the creation of a VulkanBuffer that is not host visible (push is done with a temporary buffer).
	## Switching some ShaderParameter to the new smart staging buffer ?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


-- DONE --


-- Materials --

[X] # Adding configuration properties for rendering order

-- Inputs --

[X] # Implementing mouse detection input and easily get it's screen position.


-- Gizmo Drawer --

[X] # Adding configuration properties for GraphicsPipeline to draw wire lines.
[X] # Creating a gizmo material (no depth testing, line).
[X] # Gizmos are rendered by pushing commands every frame. For each frame, these commands are consumed and executed.
[X] # Clearing the generic Graphics pipeline from ifs. And removing material type.

-- Gizmo Drawer --

[X] # MeshBoundBox gizmos rendering must be done to a specific system. (owned by the editor module.).
[X] # Adding rendering order to materials.

-- Log --

[X] # Creating my own Log library that defer log messages.

-- ECS --

[X] # REFACTOR - Moving the Engine sequencer to a SortedVector.

[X] # Right now, the ECS engine is immediate. This means that Entities, Component and Systems are created immediately when asked (and the associated events are also triggered immediately).
  Is we imagine that a System creates a child Entity on the fly when component is attached, this can create some undefined behavior.
  Also, in the future it may be safre to defere ECS operations inside a multithreaded environment. 
  
  ## Deferring every ECS Engine operations (Entity creation, System creation, Component creation) :
	- Creating a single entry point that dispach requested message.
	- Creating a sync entry point that consume messages until there is no more.

-- ECS --

[X] # Custom container for ECS components (instead of unordered_map which may not be as efficient as linear search for small amount of entries).

-- Math --

[X] # Creating my own math library. Removing dependencies from glm.

-- Physics/MeshRenderer --

# The MeshRenderer has a Bounding BOX axis aligned in local space that is calculated only once based on vertices local positions.
	[X] ## Having a child object for ECS system (like component).
	[X] ## The MeshRendererBoundingBoxSystem reacts to the presence of MeshRenderer and MeshRendererBound. On creation, a bound calculation operation is added to a vector that is consumed by the system.


-- Materials Generalizaion --

[X] # Simplifying the GraphicsPipeline creation (like texture).

[X] # Having multiple materials and instance that are rendered in a given order.
	[X] ## Removing Material instance value from MeshRenderer ? Only a pointer is necessary (and allocate the instance on the heap).
	[X] ## How to handle clearing value ? Is it possible to create a render pass only for clearing at the beginning ?
	[X] ## As a test, rendering the same model twice that have different materials.

[X] # Moving MeshStep creation to ECS system instead of mesh renderer component.


-- Transforms --

[X] # Make only transforms that have moved the last frame update their data to GPU.s

[X] Simplifying _ECS::Systems creation, there is a lot of repetition between Systems.
  A system is just a set of functions that do operations on some entity components.
	[X] Creating my own vector so that the system object can be allocated with calloc ?

[X] # Create transform hierarchy.



-- Input --

# Creating the Input system.
	[X] ## That provides simple way to query if mouse, or key has been pressed this frame, released this frame or is on hold.

# Creating a debug console in ImGUI.
	[X] ## Having a simple command that print something to logs.

Goal : Having a command that shows transform with the associated Entity ID (it's pointer address at least) ?
  SubGoals :
	 [X] Centralizing the game camera data to a system instead of handling logic in the Camera component.

-- ECS --
[X] # Provinding a uniquea and safe way to get the child component.

-- --

[X] - # Fixing the Transform system to be able to retrieve the Model matrix correctly.

[X] - # Creating the Camera component.
[X] - # Setting up Camera BufferObject.
	-> Single VulkanBuffer containing the view and perspective matrices.
	-> Binded before binding the graphics pipeline

-- Texture --
[X] # Cleaning and separating the dependency between MaterialInstance and Texture.
[X] # MaterialInstance source data are the same and not cached. (using the same instance for example ?)