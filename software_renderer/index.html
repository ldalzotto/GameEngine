<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Software Renderer - Software Renderer</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <link href="../css/custom.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Data model", url: "#_top", children: [
          ]},
          {title: "Render pipeline", url: "#render-pipeline", children: [
          ]},
          {title: "Simplifications", url: "#simplifications", children: [
              {title: "1. Breaking objects to polygons", url: "#1-breaking-objects-to-polygons" },
              {title: "2. Breaking polygons to pixels", url: "#2-breaking-polygons-to-pixels" },
              {title: "3 Pixel shading", url: "#3-pixel-shading" },
              {title: "3.1 Texture mapping", url: "#31-texture-mapping" },
          ]},
          {title: "Resources", url: "#resources", children: [
          ]},
        ];

    </script>
    <script src="../js/base.js"></script>
      <script src="../js/custom.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../entity_editor_selection/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../entity_editor_selection/" class="btn btn-xs btn-link">
        Entity editor selection
      </a>
    </div>
    
  </div>

    

    <p>The software renderer is the algorithm that draw 3D objects on the screen without using the GPU. This means that all graphics pipeline steps must be implemented from scratch, from colouring pixels to object culling. <br/></p>
<p>The renderer supports :</p>
<ul>
<li>Object culling.</li>
<li>Polygon culling.</li>
<li>Polygon clipping.</li>
<li>Polygon rasterization.</li>
<li>Polygon perspective interpolation. </li>
<li>Pixel depth buffer test.</li>
<li>Pixel texture mapping</li>
<li>Pixel shading.</li>
</ul>
<p>The whole algorithm consists of breaking objects to polygons to pixels by filtering the maximum number of data for each steps.</p>
<p>The algorithm can be divided in three steps :</p>
<ol>
<li>Breaking objects to polygons.</li>
<li>Breaking polygons to pixels.</li>
<li>Pixel shading.</li>
</ol>
<h1 id="data-model">Data model</h1>
<p><svg-inline src="software_renderer_data_model.svg""></svg-inline></p>
<p><strong>Material:</strong></p>
<p>The rendered color of the object with an optional texture. The material is used in the pixel shading stage. <br/>
Materials can be typed to be assigned to different render pipeline :</p>
<ul>
<li>NotShaded_NotTextured</li>
<li>NotShaded_Textured</li>
<li>FlatShaded_Textured</li>
<li>FlatShaded_NotTextured</li>
</ul>
<p>Flat shaded means that polygon faces act as if they are flat surface.</p>
<p><strong>RederedObject:</strong></p>
<p>The rendered object is the 3D object definition, it contains all informations to provide to the render pipeline to draw a 3D object.</p>
<h1 id="render-pipeline">Render pipeline</h1>
<p>A render pipeline is the algorithm that draw 3D objects on a target texture. For every pipeline, all steps are the same, but the pixel shading step may differ depending of the material type. Is there texture mapping ? Do we need perspective interpolation ? Is flat shade enabled ? 
Different answers to these questions will produce different render pipeline. Even if this imply some small code duplication sometimes.</p>
<p>This choice has been made to :</p>
<ol>
<li>Avoid branching inside inside pipeline as mush as possible. All pipelines are straightforward, more readable and performance problems may be easy to find and fix.</li>
<li>Having no performance impact of introducing a new render pipeline.</li>
</ol>
<p><svg-inline src="software_renderer_flow.svg""></svg-inline></p>
<p>Every render pipeline take the following inputs :</p>
<ul>
<li>A camera with view matrix, projection matrix and precomputed frustum.</li>
<li>A depth texture buffer.</li>
<li>The target rendered texture.</li>
<li>An array of rendered objects.</li>
</ul>
<h1 id="simplifications">Simplifications</h1>
<ul>
<li>We assume that polygons are always triangles. This makes the polygon rasterization and interpolation straightforward.</li>
<li>The render texture is defined by floating point and is the target texture used as output of the renderer.</li>
</ul>
<h3 id="1-breaking-objects-to-polygons">1. Breaking objects to polygons</h3>
<h4 id="11-camera-space-projection">1.1 Camera space projection</h4>
<p>Every rendered objects positions are projected into camera space by using the rendered object model matrix and the camera view matrix.</p>
<h4 id="12-object-culling">1.2 Object culling</h4>
<p>Rendered objects are filtered by checking if the mesh bounding sphere intersects with the camera frustum.</p>
<p>Once the bounding sphere is projected in camera space, we create three segments along the X,Y,Z (camera local space) and we check if each segments intersect or are contained within the camera frustum planes. 
If at least one segment is not, then the entire object is ensured to not be visible, so it is discarded.</p>
<h4 id="13-objects-break-to-polygons">1.3 Objects break to polygons</h4>
<p>For every objects, we extract all polygons and vertices from the mesh. Because every polygons are unique and may share the same vertices, camera and world positions of vertices are calculated only if they haven't been calculated already, 
this avoids to do the same matrix projection multiple times.</p>
<h4 id="14-polygon-backface-culling">1.4 Polygon backface culling</h4>
<p>Only one side of polygons are rendered. To avoid pushing polygons that will not be rendered all polygons that are not facing the camera are discarded. <br/></p>
<p>This is done by calculating the oriented normal of the polygon and project it on the camera forward direction. </p>
<h3 id="2-breaking-polygons-to-pixels">2. Breaking polygons to pixels</h3>
<h4 id="21-polygon-clipping">2.1 Polygon clipping</h4>
<p>The polygon clipping allows us to remove polygons that are beyond the camera. Projecting a point beyond the camera in clip space will produce garbage values so we filter them.</p>
<p>This is done by ensuring that for every polygons in camera space, the forward (Z axis) value of every vertices are &gt; 0.</p>
<blockquote>
<p><strong>WARNING:</strong> This solution makes polygons popping in and out when they move across the camera. A smarter solution would be to cut the polygon with the near plane and discard only the cutted part that is behind the camera.  </p>
</blockquote>
<h4 id="22-polygon-sorting">2.2 Polygon sorting</h4>
<p>Polygons are sorted by their distance from camera to render them from near to far. <br/> 
This step is required to avoid overdrawing as much as possible. Polygons near to the camera are more likely to hide others.</p>
<h4 id="23-rasterization">2.3 Rasterization</h4>
<p>Once the polygon has been projected to screen space, the rasterization function tells us if one pixel is inside the polygon. <br/>
The rasterization can be divided in three step.</p>
<p><strong>Polygon bounding box calculation:</strong></p>
<p>To avoid to check all pixel of the rendered texture, we calculate the bounding box of the polygon that will discard all other pixels of the iteration.</p>
<p><strong>Polygon edge function check:</strong></p>
<p>To know if the pixel is inside the polygon, we calculate the edge function relative to the pixel for the three edges of the polygon.<br/>
The edge function calculates the signed area of the parallelogram defined by the edge and pixel point. If all areas are positive, then this means that the pixel is inside.</p>
<p><strong>Interpolation factors:</strong></p>
<p>We want to be able to interpolate data associated to vertices to all pixels. An interpolated value for a pixel is defined as (V1 * I1) + (V2 * I2) + (V3 * I3) where V1, V2 and V3 are the datas associated to vertices. I1, I2 and I3 are the interpolation factors.</p>
<p>For vertex V1, the interpolation factor is the ratio between the area calculated by the edge function relative to the (V2-V3) edge and the pixel and the area calculated by the edge function relative to the (V2-V3) edge and the V1 position. <br/>
If the pixel is positioned at V1, then I1 will be 1 and I2 and I3 will be zero because their areas is shrank to a segment. </p>
<p><svg-inline src="software_renderer_interpolation.svg"></svg-inline></p>
<h4 id="24-depth-testing">2.4 Depth testing</h4>
<p>Multiple polygon can write to the same pixel. We must be sure that the final pixel color corresponds to the pixel that is the nearest from the camera. To do so, we interpolate vertices depth along the polygon and compare it's value against a depth texture that have the same size as the render target.
If the pixel pass the test, it's depth is written to the depth texture.</p>
<p>Using a linear interpolation with the interpolation factors will lead to distortion. Because the depth no longer exist in the render target texture, a pixel with X,Y coordinate will be interpolated the same way if it's depth is 0.5 or 1. <br/>
To take the perspective into account, we must linearly interpolate the value with a 1.0f/z factor.  </p>
<h3 id="3-pixel-shading">3 Pixel shading</h3>
<p>The pixel shading will write the calculated color of every pixel to the render target texture. Color inputs are provided by the material of the rendered object.</p>
<h3 id="31-texture-mapping">3.1 Texture mapping</h3>
<p>Texture mapping is done by assigning uv coordinates to vertices. So by using the perspective interpolation, we get UV coordinates per pixels and request back the texture.</p>
<blockquote>
<p>No filtering is applied.</p>
</blockquote>
<h1 id="resources">Resources</h1>
<p><a href="https://1drv.ms/b/s!AsTOe2fn2yZvhWEU_lpIeQxNa7I5?e=vXK9aV">polygon rasterization</a></p>
<p><a href="https://1drv.ms/b/s!AsTOe2fn2yZvhVOD173Leo14ojcf?e=th27GE">perspective-correct interpolation</a></p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../entity_editor_selection/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../entity_editor_selection/" class="btn btn-xs btn-link">
        Entity editor selection
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>